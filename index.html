<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CPU‑Only Path Tracer Benchmark</title>
<style>
  body {font-family: monospace; margin: 2rem; background:#222;color:#eee;}
  #canvas{border:1px solid #555;background:#111;}
  #controls{margin-top:1rem;}
  button, select{padding:.5rem 1rem;font-size:1rem;margin-right:.5rem;}
  #results{margin-top:1rem;white-space:pre-wrap;}
</style>
</head>
<body>
<h1>CPU‑Only Path Tracer Benchmark</h1>
<canvas id="canvas" width="1200" height="1200"></canvas>

<div id="controls">
  <select id="complexity">
    <option value="light">Light</option>
    <option value="medium">Medium</option>
    <option value="heavy">Heavy</option>
  </select>
  <button id="start">Start Benchmark</button>
  <button id="stop" disabled>Stop (while rendering)</button>
</div>

<div id="results"></div>

<script>
// ------------------------------------------------------------
// Vec3 and Helpers
class Vec3{
  constructor(x,y,z){this.x=x;this.y=y;this.z=z;}
  add(v){return new Vec3(this.x+v.x,this.y+v.y,this.z+v.z);}
  sub(v){return new Vec3(this.x-v.x,this.y-v.y,this.z-v.z);}
  mul(t){return new Vec3(this.x*t,this.y*t,this.z*t);}
  div(t){return this.mul(1/t);}
  mulV(v){return new Vec3(this.x*v.x,this.y*v.y,this.z*v.z);}
  dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}
  cross(v){
    return new Vec3(
      this.y*v.z-this.z*v.y,
      this.z*v.x-this.x*v.z,
      this.x*v.y-this.y*v.x
    );
  }
  length(){return Math.sqrt(this.dot(this));}
  unit(){return this.div(this.length());}
}
function rand(){return Math.random();}
function randInUnitSphere(){
  while(true){
    const p = new Vec3(rand()*2-1, rand()*2-1, rand()*2-1);
    if(p.dot(p)<1) return p;
  }
}
function clamp(x){return x<0?0:x>1?1:x;}
function to255(x){return Math.floor(255*clamp(x));}
function writeColor(ctx, x, y, pixelColor, samplesPerPixel){
  const r = Math.sqrt(pixelColor.x / samplesPerPixel);
  const g = Math.sqrt(pixelColor.y / samplesPerPixel);
  const b = Math.sqrt(pixelColor.z / samplesPerPixel);
  ctx.fillStyle = `rgb(${to255(r)},${to255(g)},${to255(b)})`;
  ctx.fillRect(x, y, 1, 1);
}

// ------------------------------------------------------------
// Ray, Hit, Material
class Ray{
  constructor(origin, dir){this.o=origin;this.d=dir.unit();}
  at(t){return this.o.add(this.d.mul(t));}
}
class HitRecord{
  constructor(){this.p=null;this.n=null;this.t=0;this.frontFace=true;this.mat=null;}
  setFaceNormal(r, outwardNormal){
    this.frontFace = r.d.dot(outwardNormal) < 0;
    this.n = this.frontFace ? outwardNormal : outwardNormal.mul(-1);
  }
}
class Lambertian{
  constructor(albedo){this.albedo=albedo;}
  scatter(rIn, rec){
    const scatterDir = rec.n.add(randInUnitSphere()).unit();
    const scattered = new Ray(rec.p, scatterDir);
    return {scattered, attenuation: this.albedo};
  }
}

// ------------------------------------------------------------
// Sphere
class Sphere{
  constructor(center, radius, mat){this.center=center;this.radius=radius;this.mat=mat;}
  hit(r, tMin, tMax, rec){
    const oc = r.o.sub(this.center);
    const a = r.d.dot(r.d);
    const halfB = oc.dot(r.d);
    const c = oc.dot(oc)-this.radius*this.radius;
    const discriminant = halfB*halfB - a*c;
    if(discriminant<0) return false;
    const sqrtd = Math.sqrt(discriminant);
    let root = (-halfB - sqrtd)/a;
    if(root<tMin || root>tMax){
      root = (-halfB + sqrtd)/a;
      if(root<tMin || root>tMax) return false;
    }
    rec.t=root;
    rec.p=r.at(root);
    const outwardNormal = rec.p.sub(this.center).div(this.radius);
    rec.setFaceNormal(r,outwardNormal);
    rec.mat=this.mat;
    return true;
  }
}

// ------------------------------------------------------------
// Scene and Camera
let world = [];
let origin, lowerLeftCorner, horizontal, vertical;

function setupCamera(sceneSize){
  const aspectRatio = 1;
  const viewportHeight = 2;
  const viewportWidth = aspectRatio * viewportHeight;
  const focalLength = 1;

  // Move camera back based on scene size
  origin = new Vec3(0, sceneSize > 10 ? 2 : 0, sceneSize + 1.5);
  horizontal = new Vec3(viewportWidth * sceneSize, 0, 0);
  vertical = new Vec3(0, viewportHeight * sceneSize, 0);
  lowerLeftCorner = origin
    .sub(horizontal.div(2))
    .sub(vertical.div(2))
    .sub(new Vec3(0, 0, focalLength * sceneSize));
}

function buildScene(level){
  world = [];
  const groundMat = new Lambertian(new Vec3(0.5, 0.5, 0.5));
  world.push(new Sphere(new Vec3(0,-1000,0), 1000, groundMat));

  // Static main spheres
  world.push(new Sphere(new Vec3(0,1,0), 1, new Lambertian(new Vec3(0.7,0.3,0.3))));
  world.push(new Sphere(new Vec3(-2,1,0), 1, new Lambertian(new Vec3(0.8,0.8,0.8))));
  world.push(new Sphere(new Vec3(2,1,0), 1, new Lambertian(new Vec3(0.8,0.6,0.2))));

  let count = 0;
  if(level === "light") count = 10;
  if(level === "medium") count = 100;
  if(level === "heavy") count = 500;

  for(let a = -11; a < 11 && count > 0; a++){
    for(let b = -11; b < 11 && count > 0; b++){
      const center = new Vec3(a + 0.9*rand(), 0.2, b + 0.9*rand());
      if(center.sub(new Vec3(4,0.2,0)).length() > 0.9){
        const albedo = new Vec3(rand()*rand(), rand()*rand(), rand()*rand());
        world.push(new Sphere(center, 0.2, new Lambertian(albedo)));
        count--;
      }
    }
  }

  setupCamera(level === "light" ? 3 : level === "medium" ? 8 : 14);
}

function hitWorld(r, tMin, tMax, rec){
  let tempRec = new HitRecord();
  let hitAnything=false;
  let closestSoFar=tMax;
  for(const obj of world){
    if(obj.hit(r, tMin, closestSoFar, tempRec)){
      hitAnything=true;
      closestSoFar = tempRec.t;
      Object.assign(rec, tempRec);
    }
  }
  return hitAnything;
}

// ------------------------------------------------------------
// Ray color
function rayColor(r, depth){
  if(depth<=0) return new Vec3(0,0,0);
  const rec = new HitRecord();
  if(hitWorld(r, 0.001, Infinity, rec)){
    const scatter = rec.mat.scatter(r, rec);
    if(scatter){
      const col = rayColor(scatter.scattered, depth-1);
      return scatter.attenuation.mulV(col);
    }
    return new Vec3(0,0,0);
  }
  const unitDir = r.d.unit();
  const t = 0.5*(unitDir.y+1.0);
  return new Vec3(1,1,1).mul(1.0-t).add(new Vec3(0.5,0.7,1.0).mul(t));
}

// ------------------------------------------------------------
// Rendering
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const imageWidth = canvas.width;
const imageHeight = canvas.height;
const samplesPerPixel = 20;
const maxDepth = 5;
let rendering = false;
let cancelRequested = false;

function renderPixel(x,y){
  let pixelColor = new Vec3(0,0,0);
  for(let s=0; s<samplesPerPixel; s++){
    const u = (x + rand()) / (imageWidth-1);
    const v = (y + rand()) / (imageHeight-1);
    const r = new Ray(
      origin,
      lowerLeftCorner
        .add(horizontal.mul(u))
        .add(vertical.mul(v))
        .sub(origin)
    );
    pixelColor = pixelColor.add(rayColor(r, maxDepth));
  }
  writeColor(ctx, x, y, pixelColor, samplesPerPixel);
}

async function render(){
  rendering = true;
  cancelRequested = false;
  document.getElementById('stop').disabled = false;
  const start = performance.now();
  for(let j=imageHeight-1; j>=0 && !cancelRequested; --j){
    for(let i=0; i<imageWidth && !cancelRequested; ++i){
      renderPixel(i,j);
    }
    if(j % 20 === 0){ await new Promise(r=>requestAnimationFrame(r)); }
  }
  rendering = false;
  document.getElementById('stop').disabled = true;
  const end = performance.now();
  const duration = (end-start)/1000;
  const totalSamples = imageWidth*imageHeight*samplesPerPixel;
  document.getElementById('results').textContent =
    `Rendered ${imageWidth}x${imageHeight} (${samplesPerPixel} spp) in ${duration.toFixed(2)}s\n`+
    `≈ ${ (totalSamples/duration).toFixed(0)} samples/sec`;
}

// ------------------------------------------------------------
document.getElementById('start').addEventListener('click', ()=>{
  if(rendering) return;
  const level = document.getElementById('complexity').value;
  buildScene(level);
  ctx.clearRect(0,0,imageWidth,imageHeight);
  document.getElementById('results').textContent = 'Running...';
  render();
});

document.getElementById('stop').addEventListener('click', ()=>{
  cancelRequested = true;
});
</script>
</body>
</html>

