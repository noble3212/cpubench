<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CPU‑Only Path Tracer Benchmark</title>
<style>
  body {font-family: monospace; margin: 2rem; background:#222;color:#eee;}
  #canvas{border:1px solid #555;background:#111;}
  #controls{margin-top:1rem;}
  button{padding:.5rem 1rem;font-size:1rem;margin-right:.5rem;}
  #results{margin-top:1rem;white-space:pre-wrap;}
</style>
</head>
<body>
<h1>CPU‑Only Path Tracer Benchmark</h1>
<canvas id="canvas" width="1200" height="1200"></canvas>

<div id="controls">
  <button id="start">Start Benchmark</button>
  <button id="stop" disabled>Stop (while rendering)</button>
</div>

<div id="results"></div>

<script>
// ------------------------------------------------------------
// Simple Vector3 helper
class Vec3{
  constructor(x,y,z){this.x=x;this.y=y;this.z=z;}
  add(v){return new Vec3(this.x+v.x,this.y+v.y,this.z+v.z);}
  sub(v){return new Vec3(this.x-v.x,this.y-v.y,this.z-v.z);}
  mul(t){return new Vec3(this.x*t,this.y*t,this.z*t);}
  div(t){return this.mul(1/t);}
  mulV(v){return new Vec3(this.x*v.x,this.y*v.y,this.z*v.z);}
  dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}
  cross(v){
    return new Vec3(
      this.y*v.z-this.z*v.y,
      this.z*v.x-this.x*v.z,
      this.x*v.y-this.y*v.x
    );
  }
  length(){return Math.sqrt(this.dot(this));}
  unit(){return this.div(this.length());}
}
function rand(){return Math.random();}
function randInUnitSphere(){
  while(true){
    const p = new Vec3(rand()*2-1, rand()*2-1, rand()*2-1);
    if(p.dot(p)<1) return p;
  }
}
function clamp(x){return x<0?0:x>1?1:x;}
function to255(x){return Math.floor(255*clamp(x));}
function writeColor(ctx, x, y, pixelColor, samplesPerPixel){
  const r = Math.sqrt(pixelColor.x / samplesPerPixel);
  const g = Math.sqrt(pixelColor.y / samplesPerPixel);
  const b = Math.sqrt(pixelColor.z / samplesPerPixel);
  ctx.fillStyle = `rgb(${to255(r)},${to255(g)},${to255(b)})`;
  ctx.fillRect(x, y, 1, 1);
}

// ------------------------------------------------------------
// Ray and Hit
class Ray{
  constructor(origin, dir){this.o=origin;this.d=dir.unit();}
  at(t){return this.o.add(this.d.mul(t));}
}
class HitRecord{
  constructor(){this.p=null;this.n=null;this.t=0;this.frontFace=true;this.mat=null;}
  setFaceNormal(r, outwardNormal){
    this.frontFace = r.d.dot(outwardNormal) < 0;
    this.n = this.frontFace ? outwardNormal : outwardNormal.mul(-1);
  }
}

// ------------------------------------------------------------
// Materials
class Lambertian{
  constructor(albedo){this.albedo=albedo;}
  scatter(rIn, rec){
    const scatterDir = rec.n.add(randInUnitSphere()).unit();
    const scattered = new Ray(rec.p, scatterDir);
    return {scattered, attenuation: this.albedo};
  }
}

// ------------------------------------------------------------
// Sphere
class Sphere{
  constructor(center, radius, mat){this.center=center;this.radius=radius;this.mat=mat;}
  hit(r, tMin, tMax, rec){
    const oc = r.o.sub(this.center);
    const a = r.d.dot(r.d);
    const halfB = oc.dot(r.d);
    const c = oc.dot(oc)-this.radius*this.radius;
    const discriminant = halfB*halfB - a*c;
    if(discriminant<0) return false;
    const sqrtd = Math.sqrt(discriminant);
    let root = (-halfB - sqrtd)/a;
    if(root<tMin || root>tMax){
      root = (-halfB + sqrtd)/a;
      if(root<tMin || root>tMax) return false;
    }
    rec.t=root;
    rec.p=r.at(root);
    const outwardNormal = rec.p.sub(this.center).div(this.radius);
    rec.setFaceNormal(r,outwardNormal);
    rec.mat=this.mat;
    return true;
  }
}

// ------------------------------------------------------------
// World
const world = [];
world.push(new Sphere(new Vec3(0,-100.5,-1), 100, new Lambertian(new Vec3(0.8,0.8,0.0))));
world.push(new Sphere(new Vec3(0,0,-1), 0.5, new Lambertian(new Vec3(0.7,0.3,0.3))));
world.push(new Sphere(new Vec3(-1,0,-1), 0.5, new Lambertian(new Vec3(0.8,0.8,0.8))));
world.push(new Sphere(new Vec3(1,0,-1), 0.5, new Lambertian(new Vec3(0.8,0.6,0.2))));

function hitWorld(r, tMin, tMax, rec){
  let tempRec = new HitRecord();
  let hitAnything=false;
  let closestSoFar=tMax;
  for(const obj of world){
    if(obj.hit(r, tMin, closestSoFar, tempRec)){
      hitAnything=true;
      closestSoFar = tempRec.t;
      rec.t = tempRec.t;
      rec.p = tempRec.p;
      rec.n = tempRec.n;
      rec.frontFace = tempRec.frontFace;
      rec.mat = tempRec.mat;
    }
  }
  return hitAnything;
}

// ------------------------------------------------------------
// Camera
const aspectRatio = 1;
const viewportHeight = 2;
const viewportWidth = aspectRatio*viewportHeight;
const focalLength = 1;
const origin = new Vec3(0,0,0);
const horizontal = new Vec3(viewportWidth,0,0);
const vertical = new Vec3(0,viewportHeight,0);
const lowerLeftCorner = origin
  .sub(horizontal.div(2))
  .sub(vertical.div(2))
  .sub(new Vec3(0,0,focalLength));

// ------------------------------------------------------------
// Ray color (recursive)
function rayColor(r, depth){
  if(depth<=0) return new Vec3(0,0,0);
  const rec = new HitRecord();
  if(hitWorld(r, 0.001, Infinity, rec)){
    const scatter = rec.mat.scatter(r, rec);
    if(scatter){
      const att = scatter.attenuation;
      const col = rayColor(scatter.scattered, depth-1);
      return att.mulV(col);
    }
    return new Vec3(0,0,0);
  }
  const unitDir = r.d.unit();
  const t = 0.5*(unitDir.y+1.0);
  return new Vec3(1.0,1.0,1.0).mul(1.0-t).add(new Vec3(0.5,0.7,1.0).mul(t));
}

// ------------------------------------------------------------
// Rendering / Benchmark
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const imageWidth = canvas.width;
const imageHeight = canvas.height;
const samplesPerPixel = 50; // tweak to change benchmark load
const maxDepth = 5;
let rendering = false;
let cancelRequested = false;

function renderPixel(x,y){
  let pixelColor = new Vec3(0,0,0);
  for(let s=0; s<samplesPerPixel; s++){
    const u = (x + rand()) / (imageWidth-1);
    const v = (y + rand()) / (imageHeight-1);
    const r = new Ray(
      origin,
      lowerLeftCorner
        .add(horizontal.mul(u))
        .add(vertical.mul(v))
        .sub(origin)
    );
    pixelColor = pixelColor.add(rayColor(r, maxDepth));
  }
  writeColor(ctx, x, y, pixelColor, samplesPerPixel);
}

async function render(){
  rendering = true;
  cancelRequested = false;
  const start = performance.now();
  for(let j=imageHeight-1; j>=0 && !cancelRequested; --j){
    for(let i=0; i<imageWidth && !cancelRequested; ++i){
      renderPixel(i,j);
    }
    if(j % 20 === 0){ // allow UI updates every 20 rows
      await new Promise(r=>requestAnimationFrame(r));
    }
  }
  const end = performance.now();
  rendering = false;
  const duration = (end-start)/1000;
  const totalSamples = imageWidth*imageHeight*samplesPerPixel;
  document.getElementById('results').textContent =
    `Rendered ${imageWidth}x${imageHeight} (${samplesPerPixel} spp) in ${duration.toFixed(2)}s\n`+
    `≈ ${ (totalSamples/duration).toFixed(0)} samples per second`;
}

// ------------------------------------------------------------
document.getElementById('start').addEventListener('click', ()=>{
  if(rendering) return;
  ctx.clearRect(0,0,imageWidth,imageHeight);
  document.getElementById('results').textContent = 'Running...';
  render();
});
document.getElementById('stop').addEventListener('click', ()=>{
  cancelRequested = true;
});

</script>
</body>
</html>
